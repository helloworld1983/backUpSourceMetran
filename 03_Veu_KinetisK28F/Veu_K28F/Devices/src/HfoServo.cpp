/******************************************************************************/
//$COMMON.H$
//    Filename: HfoServo.cpp
//    Copyright 1996 InVentive Technologies, Inc. All Rights Reserved.
//
//    Class:  HfoServo
//    This class controls hfo servo
/******************************************************************************/
#include "HfoServo.h"
#include "assignments.h"

#include "Stepmoto.h"

#include "MgrBdSetting.h"
#include "MgrBreathData.h"
#include "math.h"
#include "HFOAlarmTrigger.h"

#include "MgrStemMotor.h"
#include "MgrDiscreteInput.h"
#include "CommonTypes.h"
#include "SinTable.h"

#define Kp 2
#define Ki 0.0098
#define Kd 0.0008
#define POSITS	(1000)

#define MAX_HFO_FREQ    17
#define MIN_HFO_FREQ    5
/* int32_t : long , int16_t : int or short which is the same as int*/

struct two_16bit
{
    int16_t Low16;
    int16_t High16;
};
union One_32bit
{
    int32_t Long32;
    struct two_16bit  access16;
};
union One_32bit  Sum;

#define		MIN_STROKE_FOR_OPEN_LOOP	10	// 10 scale by 10
#define		MAX_STROKE_FOR_OPEN_LOOP	450 // 45 scale by 10

#define	Five_Minutes	(int32_t)150000
#define	Five_MPls10s	(int32_t)155000
#define	Ten_Minutes		(int32_t)300000
#define Thirty_Minutes	(int32_t)900000
#define	One_MPls10s	(int32_t) 35000
#define	One_Minutes	(int32_t)	30000
#define	Two_Minutes		(int32_t) 60000

/* DAS_Counter is increased every 2ms.
 0 ~ Five_Minutes : 0 to 5 minutes , Open loop according to the volume table
       from 5 to 10 s , remembered pressure amplitude as : PresAmp_Cmd
 Five_Minutes ~ Five_MPls10s :5 minutes to 5 minutes+10seconds , closed amplitude control
           according to remembered PresAmp_Cmd.
 Five_MPls10s ~ Ten_Minutes : 5minutes+10s ~ 10 minutes , open loop according to the motor step
           generated by direct amplitude control .
 */

#define	Make_DCShift	(0)
#define	PresAmp50		(1)
#define	Sign_Res			(2)
#define	Lower_SV			(3)

#define E_Point	0
#define	H_Point	389
#define Initial_Angle	750

#define HFO_START_OFFSET	H_Point
#define NUM_VOL_ENTRIES	80
#define	LENGTH_SINTBL	1000
#define INITIAL_ANGLE	750
#define MAX_STEP		1347
#define MAP_SERVO_SCALE		(8)
#define SIMV_SEAL_STEP		(0)
#define SHIFT_INCREMENT 	5

#define MOTOR_BACKED_OUT_STEP	(1400)

#define PISTON_INTERLOCK	0x04

#define HFO_SOLENOID	0x04

#define	DEC_STROKE_VOL_LIMIT (400)

#define HFO_STROKE_LIMIT	(1600)

#define MIN_FREQ 5

#define HFO_MAX_STEP 2000


/* Small stroke volume table*/

//  Dec portion.
//	0.0	0.2	0.4	0.6	0.8	  
static const int32_t steps_for_small_str[DEC_STROKE_VOL_LIMIT/2] =
{
        389,391,394,396,398,
        401,403,405,408,410,
        413,415,418,420,422,
        424,427,429,431,433,
        436,438,441,443,445,
        448,450,452,454,456,
        459,461,463,465,467,
        469,472,474,476,478,
        480,482,484,486,488,
        490,493,495,497,499,
        501,504,506,508,510,
        512,515,517,519,521,
        523,526,528,530,532,
        534,537,539,541,543,
        545,548,550,552,554,
        556,558,560,562,564,
        566,568,570,572,574,
        577,579,581,583,585,
        588,590,592,594,596,
        599,601,603,605,608,
        611,613,615,617,619,
        622,624,626,628,630,
        633,635,637,639,641,
        645,647,649,651,653,
        656,658,660,662,664,
        667,669,671,673,675,
        678,680,682,684,686,
        689,691,693,695,697,
        700,702,704,706,708,
        711,713,715,717,719,
        722,724,726,728,730,
        733,735,737,739,741,
        744,746,748,750,753,
        756,758,760,762,764,
        767,769,771,773,775,
        778,780,782,784,786,
        788,790,792,794,796,
        799,801,803,805,807,
        809,811,813,815,817,
        820,822,824,826,828
};


#define MAX_STROKE_VOL_ADJUSTMENT  160
#define MIN_STROKE_VOL_ADJUSTMENT  0
#define NUM_STROKE_INDEX (MAX_STROKE_VOL_ADJUSTMENT - MIN_STROKE_VOL_ADJUSTMENT + 1)

/* This table is indexed by the stroke volume. The values are
the HFO motor's step corresponding to the index ml volume.
These values include the HFO_START_OFFSET, also referred
to as the H Point, which is the starting point for the
HFO motor's oscillations. */
static const int32_t steps_for_ml[NUM_VOL_ENTRIES + 1] =
{
        HFO_START_OFFSET,
        401, 413, 424, 436, 448, 459, 469, 480, 490, 501,
        512, 523, 534, 545, 556, 566, 577, 588, 599, 611,
        622, 633, 645, 656, 667, 678, 689, 700, 711, 722,
        733, 744, 756, 767, 778, 788, 799, 809, 820, 830,
        837, 844, 851, 858, 865, 872, 879, 886, 893, 900,
        907, 914, 921, 928, 935, 942, 949, 956, 963, 970,
        977, 984, 991, 998, 1006,1013,1020,1027,1034,1041,
        1049,1057,1062,1068,1074,1081,1088,1095,1103,1111
};


// There are 13 different freq ( 5 to 17)
//new table for HFO motor parameter K52 = 251, K53 = 201, K54 = 4
static const int32_t steps_for_big_ml[NUM_STROKE_INDEX][13] = {

        {0,0,0,0,0,0,0,0,0,0,0,0,0},
        {10,10,10,10,10,10,10,10,10,10,10,10,10},
        {20,20,20,20,20,20,20,19,19,19,19,19,19},
        {30,30,30,30,30,30,29,29,29,29,29,29,29},
        {41,40,40,40,40,40,39,39,38,38,38,38,38},
        {51,51,50,50,50,49,49,48,48,48,48,48,48},
        {61,61,60,60,60,59,59,58,57,57,57,57,57},
        {71,71,70,70,70,69,68,68,67,67,67,67,67},
        {81,81,81,80,79,79,78,77,76,76,76,76,76},
        {91,91,91,90,89,89,88,87,86,86,86,86,86},
        {102,101,101,100,99,99,98,97,96,95,95,95,95},
        {112,111,111,110,109,109,108,106,105,105,105,105,105},
        {122,121,121,120,119,119,117,116,115,114,114,114,114},
        {132,132,131,130,129,128,127,126,124,124,124,124,124},
        {142,142,141,140,139,138,137,135,134,134,133,133,133},
        {152,152,151,150,149,148,147,145,143,143,143,143,143},
        {162,162,161,160,159,158,156,155,153,153,152,152,152},
        {173,172,171,170,169,168,166,164,163,162,162,162,162},
        {183,182,181,180,179,178,176,174,172,172,171,171,171},
        {193,192,191,190,189,188,186,184,182,181,181,181,181},
        {203,202,201,200,199,198,196,193,191,191,190,190,190},
        {213,213,211,210,209,207,205,203,201,200,200,200,200},
        {223,223,222,220,218,217,215,213,210,210,209,209,209},
        {233,233,232,230,228,227,225,222,220,219,219,219,219},
        {244,243,242,240,238,237,235,232,229,229,228,228,228},
        {254,253,252,250,248,247,245,242,239,239,238,238,238},
        {264,263,262,260,258,257,254,251,249,248,247,247,248},
        {274,273,272,270,268,267,264,261,258,258,257,257,257},
        {284,283,282,280,278,277,274,270,268,267,266,266,267},
        {294,293,292,290,288,287,284,280,277,277,276,276,276},
        {305,304,302,300,298,296,293,290,287,286,285,285,286},
        {315,314,312,310,308,306,303,299,296,296,295,295,295},
        {325,324,322,320,318,316,313,309,306,305,304,304,305},
        {335,334,332,330,328,326,323,319,315,315,314,314,314},
        {345,344,342,340,338,336,333,328,325,324,323,323,324},
        {355,354,352,350,348,346,342,338,335,334,333,333,333},
        {365,364,363,360,357,356,352,348,344,343,342,342,343},
        {376,374,373,370,367,366,362,357,354,353,352,352,352},
        {386,385,383,380,377,375,372,367,363,363,361,361,362},
        {396,395,393,390,387,385,381,377,373,372,371,371,371},
        {406,405,403,400,397,395,391,386,382,382,380,380,381},
        {416,415,413,410,407,405,401,396,392,391,390,390,390},
        {426,425,423,420,417,415,411,406,402,401,399,399,400},
        {436,435,433,430,427,425,421,415,411,410,409,409,409},
        {447,445,443,440,437,435,430,425,421,420,418,418,419},
        {457,455,453,450,447,445,440,435,430,429,428,428,428},
        {467,466,463,460,457,454,450,444,440,439,437,437,438},
        {477,476,473,470,467,464,460,454,449,448,447,447,447},
        {487,486,483,480,477,474,469,464,459,458,456,456,457},
        {497,496,493,490,487,484,479,473,468,467,466,466,466},
        {508,506,504,500,497,494,489,483,478,477,475,476,476},
        {518,516,514,509,506,504,499,493,488,487,485,485,486},
        {528,526,524,519,516,514,509,502,497,496,494,495,495},
        {538,536,534,529,526,524,518,512,507,506,504,504,505},
        {548,546,544,539,536,534,528,522,516,515,513,514,514},
        {558,557,554,549,546,543,538,531,526,525,523,523,524},
        {568,567,564,559,556,553,548,541,535,534,532,533,533},
        {579,577,574,569,566,563,557,551,545,544,542,542,543},
        {589,587,584,579,576,573,567,560,554,553,551,552,552},
        {599,597,594,589,586,583,577,570,564,563,561,561,562},
        {609,607,604,599,596,593,587,580,574,572,570,571,571},
        {619,617,614,609,606,603,597,589,583,582,580,580,581},
        {629,627,624,619,616,613,606,599,593,591,589,590,590},
        {639,638,634,629,626,622,616,609,602,601,599,599,600},
        {650,648,644,639,636,632,626,618,612,611,608,609,609},
        {660,658,655,649,645,642,636,628,621,620,618,618,619},
        {670,668,665,659,655,652,645,638,631,630,627,628,628},
        {680,678,675,669,665,662,655,647,641,639,637,637,638},
        {690,688,685,679,675,672,665,657,650,649,646,647,647},
        {700,698,695,689,685,682,675,667,660,658,656,656,657},
        {711,708,705,699,695,692,685,676,669,668,665,666,666},
        {721,719,715,709,705,701,694,686,679,677,675,675,676},
        {731,729,725,719,715,711,704,696,688,687,684,685,685},
        {741,739,735,729,725,721,714,705,698,696,694,694,695},
        {751,749,745,739,735,731,724,715,707,706,703,704,704},
        {761,759,755,749,745,741,734,725,717,716,713,713,714},
        {771,769,765,759,755,751,743,734,727,725,722,723,724},
        {782,779,775,769,765,761,753,744,736,735,732,732,733},
        {792,789,785,779,775,771,763,753,746,744,741,742,743},
        {802,799,796,789,784,781,773,763,755,754,751,751,752},
        {812,810,806,799,794,790,782,773,765,763,760,761,762},
        {822,820,816,809,804,800,792,782,774,773,770,770,771},
        {832,830,826,819,814,810,802,792,784,782,779,780,781},
        {842,840,836,829,824,820,812,802,793,792,789,789,790},
        {853,850,846,839,834,830,822,811,803,801,798,799,800},
        {863,860,856,849,844,840,831,821,813,811,808,808,809},
        {873,870,866,859,854,850,841,831,822,820,817,818,819},
        {883,880,876,869,864,860,851,840,832,830,827,827,828},
        {893,891,886,879,874,869,861,850,841,840,836,837,838},
        {903,901,896,889,884,879,870,860,851,849,846,846,847},
        {914,911,906,899,894,889,880,869,860,859,855,856,847},
        {924,921,916,909,904,899,890,879,870,868,865,865,847},
        {934,931,926,919,914,909,900,889,880,878,874,875,847},
        {944,941,937,929,923,919,910,898,889,887,884,884,847},
        {954,951,947,939,933,929,919,908,899,897,893,894,847},
        {964,961,957,949,943,939,929,918,908,906,903,903,847},
        {974,972,967,959,953,948,939,927,918,916,912,913,847},
        {985,982,977,969,963,958,949,937,927,925,922,922,847},
        {995,992,987,979,973,968,958,947,937,935,931,932,847},
        {1005,1002,997,989,983,978,968,956,946,944,941,941,847},
        {1015,1012,1007,999,993,988,978,966,956,954,950,941,847},
        {1025,1022,1017,1009,1003,998,988,976,966,964,960,941,847},
        {1035,1032,1027,1019,1013,1008,998,985,975,973,969,941,847},
        {1045,1042,1037,1029,1023,1018,1007,995,985,983,979,941,847},
        {1056,1052,1047,1039,1033,1028,1017,1005,994,992,988,941,847},
        {1066,1063,1057,1049,1043,1037,1027,1014,1004,1002,998,941,847},
        {1076,1073,1067,1059,1053,1047,1037,1024,1013,1011,1007,941,847},
        {1086,1083,1077,1069,1063,1057,1046,1034,1023,1021,1007,941,847},
        {1096,1093,1088,1079,1072,1067,1056,1043,1032,1030,1007,941,847},
        {1106,1103,1098,1089,1082,1077,1066,1053,1042,1040,1007,941,847},
        {1117,1113,1108,1099,1092,1087,1076,1063,1052,1049,1007,941,847},
        {1127,1123,1118,1109,1102,1097,1086,1072,1061,1059,1007,941,847},
        {1137,1133,1128,1119,1112,1107,1095,1082,1071,1068,1007,941,847},
        {1147,1144,1138,1129,1122,1116,1105,1092,1080,1068,1007,941,847},
        {1157,1154,1148,1139,1132,1126,1115,1101,1090,1068,1007,941,847},
        {1167,1164,1158,1149,1142,1136,1125,1111,1099,1068,1007,941,847},
        {1177,1174,1168,1159,1152,1146,1134,1121,1109,1068,1007,941,847},
        {1188,1184,1178,1169,1162,1156,1144,1130,1119,1068,1007,941,847},
        {1198,1194,1188,1179,1172,1166,1154,1140,1128,1068,1007,941,847},
        {1208,1204,1198,1189,1182,1176,1164,1150,1138,1068,1007,941,847},
        {1218,1214,1208,1199,1192,1186,1174,1159,1147,1068,1007,941,847},
        {1228,1225,1218,1209,1202,1195,1183,1169,1147,1068,1007,941,847},
        {1238,1235,1229,1219,1211,1205,1193,1179,1147,1068,1007,941,847},
        {1248,1245,1239,1229,1221,1215,1203,1188,1147,1068,1007,941,847},
        {1259,1255,1249,1239,1231,1225,1213,1198,1147,1068,1007,941,847},
        {1269,1265,1259,1249,1241,1235,1223,1208,1147,1068,1007,941,847},
        {1279,1275,1269,1259,1251,1245,1232,1217,1147,1068,1007,941,847},
        {1289,1285,1279,1269,1261,1255,1242,1227,1147,1068,1007,941,847},
        {1299,1295,1289,1279,1271,1265,1252,1236,1147,1068,1007,941,847},
        {1309,1305,1299,1289,1281,1275,1262,1246,1147,1068,1007,941,847},
        {1320,1316,1309,1299,1291,1284,1271,1256,1147,1068,1007,941,847},
        {1330,1326,1319,1309,1301,1294,1281,1256,1147,1068,1007,941,847},
        {1340,1336,1329,1319,1311,1304,1291,1256,1147,1068,1007,941,847},
        {1350,1346,1339,1329,1321,1314,1301,1256,1147,1068,1007,941,847},
        {1360,1356,1349,1339,1331,1324,1311,1256,1147,1068,1007,941,847},
        {1370,1366,1359,1349,1341,1334,1320,1256,1147,1068,1007,941,847},
        {1380,1376,1370,1359,1350,1344,1330,1256,1147,1068,1007,941,847},
        {1391,1386,1380,1369,1360,1354,1340,1256,1147,1068,1007,941,847},
        {1401,1397,1390,1379,1370,1363,1350,1256,1147,1068,1007,941,847},
        {1411,1407,1400,1389,1380,1373,1359,1256,1147,1068,1007,941,847},
        {1421,1417,1410,1399,1390,1383,1369,1256,1147,1068,1007,941,847},
        {1431,1427,1420,1409,1400,1393,1379,1256,1147,1068,1007,941,847},
        {1441,1437,1430,1419,1410,1403,1389,1256,1147,1068,1007,941,847},
        {1451,1447,1440,1429,1420,1413,1399,1256,1147,1068,1007,941,847},
        {1462,1457,1450,1439,1430,1423,1408,1256,1147,1068,1007,941,847},
        {1472,1467,1460,1449,1440,1433,1418,1256,1147,1068,1007,941,847},
        {1482,1478,1470,1459,1450,1442,1428,1256,1147,1068,1007,941,847},
        {1492,1488,1480,1469,1460,1452,1438,1256,1147,1068,1007,941,847},
        {1502,1498,1490,1479,1470,1462,1447,1256,1147,1068,1007,941,847},
        {1512,1508,1500,1489,1480,1472,1447,1256,1147,1068,1007,941,847},
        {1523,1518,1511,1499,1490,1482,1447,1256,1147,1068,1007,941,847},
        {1533,1528,1521,1508,1499,1492,1447,1256,1147,1068,1007,941,847},
        {1543,1538,1531,1518,1509,1502,1447,1256,1147,1068,1007,941,847},
        {1553,1548,1541,1528,1519,1512,1447,1256,1147,1068,1007,941,847},
        {1563,1558,1551,1538,1529,1522,1447,1256,1147,1068,1007,941,847},
        {1573,1569,1561,1548,1539,1522,1447,1256,1147,1068,1007,941,847},
        {1583,1579,1571,1558,1549,1522,1447,1256,1147,1068,1007,941,847},
        {1594,1589,1581,1568,1559,1522,1447,1256,1147,1068,1007,941,847},
        {1604,1599,1591,1578,1569,1522,1447,1256,1147,1068,1007,941,847},
        {1614,1609,1601,1588,1579,1522,1447,1256,1147,1068,1007,941,847},
        {1624,1619,1611,1598,1589,1522,1447,1256,1147,1068,1007,941,847}
};

//This table is an offset for matching with amplitude curve in Humming V
static const int32_t steps_offset_for_HummingV[NUM_STROKE_INDEX][13] = {

        {0,0,0,0,0,0,0,0,0,0,0,0,0},                           //SV0
        {2,2,2,2,2,2,2,2,2,3,4,4,3},
        {5,5,5,5,5,5,5,5,5,6,8,8,7},
        {8,8,8,8,8,8,8,8,8,9,11,12,11},
        {11,11,11,11,11,11,11,11,11,13,15,16,14},
        {14,14,14,14,14,14,14,14,14,16,19,20,18},
        {17,17,17,17,17,17,17,17,17,20,23,24,21},
        {20,20,20,20,20,20,20,20,20,24,27,27,25},
        {23,23,23,23,23,23,23,23,23,28,30,30,28},
        {26,26,26,26,26,26,26,26,26,31,34,33,31},
        {29,29,29,29,29,29,29,29,29,35,37,36,34},               //SV10
        {32,32,32,32,32,32,32,32,32,38,40,39,36},
        {35,35,35,35,35,35,35,35,35,41,43,41,38},
        {37,37,37,37,37,37,37,37,37,44,46,43,40},
        {39,39,39,39,39,39,39,39,39,46,48,45,42},
        {41,41,41,41,41,41,41,41,41,49,50,47,44},
        {43,43,43,43,43,43,43,43,43,51,53,48,45},
        {45,45,45,45,45,45,45,45,45,53,54,50,46},
        {46,46,46,46,46,46,46,46,46,54,56,51,47},
        {48,48,48,48,48,48,48,48,48,55,57,52,47},
        {49,49,49,49,49,49,49,49,49,56,59,53,48},               //SV20
        {50,50,50,50,50,50,50,50,50,57,60,53,48},
        {51,51,51,51,51,51,51,51,51,57,60,54,47},
        {52,52,52,52,52,52,52,52,52,58,61,54,47},
        {52,52,52,52,52,52,52,52,52,58,61,54,47},
        {53,53,53,53,53,53,53,53,53,57,61,53,46},
        {54,54,54,54,54,54,54,54,54,57,61,53,45},
        {54,54,54,54,54,54,54,54,54,56,61,52,44},
        {54,54,54,54,54,54,54,54,54,55,60,52,42},
        {55,55,55,55,55,55,55,55,55,54,59,51,41},
        {55,55,55,55,55,55,55,55,55,53,58,49,40},                //SV30
        {55,55,55,55,55,55,55,55,55,52,57,48,38},
        {55,55,55,55,55,55,55,55,55,51,56,47,36},
        {55,55,55,55,55,55,55,55,55,50,55,45,34},
        {56,56,56,56,56,56,56,56,56,48,53,43,32},
        {56,56,56,56,56,56,56,56,56,47,52,41,30},
        {56,56,56,56,56,56,56,56,56,45,50,39,28},
        {56,56,56,56,56,56,56,56,56,43,48,37,26},
        {56,56,56,56,56,56,56,56,56,42,46,34,24},
        {56,56,56,56,56,56,56,56,56,40,44,32,21},
        {57,57,57,57,57,57,57,57,57,38,42,29,19},                //SV40
        {57,57,57,57,57,57,57,57,57,37,40,27,16},
        {57,57,57,57,57,57,57,57,57,35,37,24,14},
        {57,57,57,57,57,57,57,57,57,33,35,21,11},
        {57,57,57,57,57,57,57,57,57,32,33,18,9},
        {57,57,57,57,57,57,57,57,57,30,30,15,6},
        {57,57,57,57,57,57,57,57,57,28,27,12,3},
        {57,57,57,57,57,57,57,57,57,27,25,8,0},
        {57,57,57,57,57,57,57,57,57,25,22,5,-3},
        {56,56,56,56,56,56,56,56,56,23,19,2,-6},
        {56,56,56,56,56,56,56,56,56,21,17,-2,-10},               //SV50
        {55,55,55,55,55,55,55,55,55,20,14,-5,-13},
        {54,54,54,54,54,54,54,54,54,18,11,-9,-17},
        {53,53,53,53,53,53,53,53,53,16,8,-12,-20},
        {52,52,52,52,52,52,52,52,52,14,5,-16,-24},
        {51,51,51,51,51,51,51,51,51,12,2,-20,-28},
        {49,49,49,49,49,49,49,49,49,10,-1,-24,-32},
        {47,47,47,47,47,47,47,47,47,8,-4,-27,-36},
        {45,45,45,45,45,45,45,45,45,5,-7,-31,-41},
        {43,43,43,43,43,43,43,43,43,3,-10,-35,-46},
        {40,40,40,40,40,40,40,40,40,0,-14,-39,-50},              //SV60
        {37,37,37,37,37,37,37,37,37,-2,-17,-43,-55},
        {33,33,33,33,33,33,33,33,33,-5,-21,-47,-60},
        {30,30,30,30,30,30,30,30,30,-8,-24,-51,-66},
        {26,26,26,26,26,26,26,26,26,-12,-28,-55,-71},
        {21,21,21,21,21,21,21,21,21,-15,-32,-59,-77},
        {17,17,17,17,17,17,17,17,17,-18,-35,-63,-82},
        {12,12,12,12,12,12,12,12,12,-22,-39,-67,-88},
        {7,7,7,7,7,7,7,7,7,-26,-44,-71,-94},
        {2,2,2,2,2,2,2,2,2,-30,-48,-76,-100},
        {-4,-4,-4,-4,-4,-4,-4,-4,-4,-34,-52,-80,-106},           //SV70
        {-10,-10,-10,-10,-10,-10,-10,-10,-10,-39,-57,-85,-112},
        {-16,-16,-16,-16,-16,-16,-16,-16,-16,-43,-62,-89,-117},
        {-21,-21,-21,-21,-21,-21,-21,-21,-21,-48,-67,-94,-123},
        {-27,-27,-27,-27,-27,-27,-27,-27,-27,-52,-72,-99,-129},
        {-33,-33,-33,-33,-33,-33,-33,-33,-33,-57,-78,-104,-134},
        {-39,-39,-39,-39,-39,-39,-39,-39,-39,-61,-84,-109,-139},
        {-44,-44,-44,-44,-44,-44,-44,-44,-44,-66,-90,-114,-144},
        {-49,-49,-49,-49,-49,-49,-49,-49,-49,-70,-96,-119,-148},
        {-53,-53,-53,-53,-53,-53,-53,-53,-53,-74,-102,-125,-152},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV80
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV90
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV100
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV110
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV120
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV130
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV140
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}, //SV150
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155},
        {-57,-57,-57,-57,-57,-57,-57,-57,-57,-78,-109,-131,-155}  //SV160
};


// This table to calculate for the dead space factor. The factor has scale up by 1000.
// To get the factor use the following formular. 
//	Offset value or the start of sine wave is x, then the factor is:
//  (x-490)%20. Since the calculation start at step 470. and each factor can be used for 20 steps.
static const int32_t adjustmentFactor[162] =
{	
        1000,1000,1000,1000,1000,1010,1010,1010,1010,1010,
        1020,1020,1020,1020,1020,1020,1030,1030,1030,1030,
        1030,1040,1040,1040,1040,1040,1040,1050,1050,1050,
        1050,1050,1060,1060,1060,1060,1060,1060,1070,1070,
        1070,1070,1070,1070,1080,1080,1080,1080,1080,1090,
        1090,1090,1090,1090,1090,1100,1100,1100,1100,1100,
        1110,1110,1110,1110,1110,1110,1120,1120,1120,1120,
        1120,1130,1130,1130,1130,1130,1130,1140,1140,1140,
        1140,1140,1140,1150,1150,1150,1150,1150,1150,1160,
        1160,1160,1160,1160,1170,1170,1170,1170,1170,1170,
        1180,1180,1180,1180,1180,1180,1180,1190,1190,1190,
        1190,1190,1190,1200,1200,1200,1200,1200,1200,1210,
        1210,1210,1210,1210,1210,1220,1220,1220,1220,1220,
        1220,1230,1230,1230,1230,1230,1230,1230,1240,1240,
        1240,1240,1240,1240,1240,1250,1250,1250,1250,1250,
        1250,1250,1250,1260,1260,1260,1260,1260,1260,1260,
        1270,1270
};
static const int32_t MAX_STROKE_VOLUME[13] ={160,160,160,160,160,154,148,130,120,112,106,99,89};

//  Define Statics
HfoServo* HfoServo::S_Instance = NULL;

HfoServo* HfoServo::S_GetInstance(void)
{
    if(NULL == S_Instance)
    {
        S_Instance = new HfoServo();
    }

    return (S_Instance);
}

bool HfoServo::PistonInstalled()
{
    bool bStatus = false;

    if(MgrDiscreteInput::HFOPistonSwitch->GetStateDirect() == eOn)
    {
        bStatus = false;
    }
    else
    {
        bStatus = true;
    }
    return bStatus;
}

/*************************************************************************/
bool HfoServo::MotorIsStopped()
{
    return stop_the_motor;
}

/*************************************************************************

 HFOSERVO_StopMotor - This function is called to let the servo to
 stop running the motor.

 *************************************************************************/

void HfoServo::StopMotor()
{
    servo_asked_for_stop = true;
}


/*************************************************************************

 HFOSERVO_ServoMotor - This function is called to let the servo to
 start running the motor.

 *************************************************************************/

//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: ServoMotor()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************

void HfoServo::ServoMotor()
{
    servo_asked_for_stop = false;
}

//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: Init()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::Init()
{
    stop_the_motor = false;
    servo_asked_for_stop = true;
}

//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: SetParameterForMotorAtOrgionalPos()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::SetParameterForMotorAtOrgionalPos()
{
    shifting_offset = 0;
    DAS_Counter		= 0;
    timeToGetTargetPress = 0;
    shifting_inc = SHIFT_INCREMENT;

}

/******************************************************************************/
//$COMMON.OPERATION$
//    Operation Name: HfoServo()
//
//    Processing: 
//      This operation is the Console Task constructor.
//
//    Input Parameters:
//      None
//
//    Output Parameters:
//      None
//
//    Return Values:
//      None
//
//    Pre-Conditions:
//      None
//
//    Miscellaneous:
//      None
//
//    Requirements:  
//
/******************************************************************************/
HfoServo::HfoServo(void)//: Controller()
{
    currentAmp = 0;
    IsDoAmpCtr = false;
    T = 0.0;
    t = 0.0,
    servo_asked_for_stop	= true;
    stop_the_motor			= true;

    shifting_offset = 0;
    DAS_Counter		= 0;

    timeToGetTargetPress = 0;
    PresAmp_Cmd = 0;
    Pres_Amp = 0;
    FPres_Amp = 0;
    Amp_ByDAC = 0;
    prevAmp_ByDAC = 0;
    OpenMtr_Amp = 0;
    integrator_DAC1 = 0;
    integrator_DAC2 = 0;
    integrator_DAC3 = 0;
    integrator_DAC4 = 0;
    UpperAmpLimit = 0;
    LowerAmpLimit = 0;

    SVUpdatecounter = 0;

    Stop_DirectAmpCtrl = Make_DCShift;


    general_timer=0;
    shift_timer = 0;
    final_step_for_vol = 0;	/* this is multiplied by the current sine */
    /* value to scale the sine to the correct volume */
    restrictor_open = true;
    Phase_Angle = (int16_t) INITIAL_ANGLE; // 3Pai /2
    shifting_inc = SHIFT_INCREMENT;
    prevStrokeVol = 0;
    disconnectFlag = false;
    //ServoCommPtr = ServoComTask::S_GetInstance();
    Dat_Omic_integrator = 0;
    DAmp_integrator = 0;
    integrator1 = 0;
    integrator2 = 0;
    ZeroOrAmp_integrator1 = 0;
    ZeroOrAmp_integrator2 = 0;
    EHPoint_integrator1 = 0;
    EHPoint_integrator2 = 0;
    freqIntegrator = 0;
    dAmpIntegrator = 0;

    shiftPosition = 0;
    shiftCounter = 0;
    shiftDirection = forward;


    delayAfterSI = 1500;
    prevSIRequest = false;

    numOfSample = 0;
    sum = 0;
    SIRequest = eFalse;
    prevSI = eFalse;
    delay_afterSI = 0;

    Amp_integral = 0;
    Amp_derivative = 0;
    Timer_20s = 0;
    finished_20s = false;

    //    OvershootCnt = 0;

    zeroIntegrator1 = 0;
    zeroIntegrator2 = 0;
    CurrentAmp = 0;
    strokeVol = 0;
    Freq = 0;
    Phase = 0;
    ZeroOrAmp = 0;
    SinPos = 0;
    HFO_Mposition = 0;
    currentSIRequest = false;
    prev_Amp_error = 0;

//    LONG valueInFILE = UNINITIALIZED_LONG_VALUE;
//    valueInFILE = ventSettingsFile->getValue(SETTING_IDX(eHummingVSettingID));

//    if(valueInFILE == 1)
//    {
//        isHummingVON = eTrue;
//    }
//    else
//    {
//        isHummingVON = eFalse;
//    }
}

/* The following macro implements the Vissim Transfer Function
where the numerator is 0 degree, the denominator is 1st degree,
the coefficient of the 1st degree is 1, and the 0 degree coefficient
is the same for the numerator and denominator. A few of these
are used to implement this servo. See HFOMOV.VSM for the
representation of this.*/

/*************************************************************************/

#define RESTRICTOR_CHANGE_TIME		((UInt32)50)

//***************************************************************************//
//
//***************************************************************************//
void HfoServo::Run()
{

//    if(eFalse == Enabled)
//    {
//        prevSI = eFalse;
//        SIRequest = eFalse;
//        delay_afterSI = 0;
//        return;
//    }

    DoServo();


}
//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: DoServo()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::DoServo()
{
    static int prevFreqSetting = 7;
    static int prevMapSetting = 3;
    static LONG timeDuringSI = 0;
    static int32_t prevStep = HFO_MAX_STEP;
    static bool IsSIReqPrev = false;
    static int delay = 500;


    static int32_t thirtyPercentDelay = 0;

    static unsigned char Stop_DirectAmpCtrl = Make_DCShift;


    //    static MsecType	general_timer=0;

    static int16_t Phase_Angle = (int16_t) INITIAL_ANGLE; // 3Pai /2

    static int16_t prevStrokeVol = 0;
    static bool disconnectFlag = false;

    static int16_t openLoopShiftAmount = 0;

    /* value to scale the sine to the correct volume */

    int32_t FPresAmp_Cmd,Temp32,finalStep, Dat_Omic,HFO_Mposition;
    int16_t Phase,stepAmp,DAmp,ZeroOrAmp,SinPos,EHPoint;
    int16_t settingStrokeVol,settingFreq = 0;

    int16_t Freq = 5;

    // Just to make sure that we have final step setup.
    finalStep = HFO_START_OFFSET;

    // Check and make sure freq is valid.
//    settingFreq =  HfoController->GetCurrentFreq();;
    if ( (settingFreq >= MIN_HFO_FREQ) && (settingFreq <= MAX_HFO_FREQ))
        Freq = settingFreq;

    if(SIRequest == eTrue)
    {
        settingStrokeVol=0;
        strokeVol = 0;
        IsSIReqPrev = true;
        timeDuringSI = timeDuringSI+2;
    }

    else if(IsSIReqPrev)
    {
        IsSIReqPrev = false;
        settingStrokeVol=0;
        strokeVol = 0;
        delay = delay -2;
    }

    else
    {
        IsSIReqPrev = false;
        delay = 500;
        timeDuringSI = 0;

        if(IsDoAmpCtr)
            settingStrokeVol = DoPID();
        else
            settingStrokeVol = MgrBdSetting::S_GetInstance()->GetCurrentValue(eHFOStrokeVolume)/10;
    }


    // Slowly update stroke volume setting.
    if(strokeVol != settingStrokeVol)
    {
        SVUpdatecounter++;

        if(SVUpdatecounter>=50)
        {
            SVUpdatecounter=0;
            if ( settingStrokeVol > strokeVol)
            {
                strokeVol += 10;
                if(strokeVol > settingStrokeVol)
                    strokeVol = settingStrokeVol;
            }
            else if (settingStrokeVol < strokeVol)
            {
                strokeVol -= 10;
                if(strokeVol < settingStrokeVol)
                    strokeVol = settingStrokeVol;
            }
        }
//        if(abs(strokeVol - settingStrokeVol)<10)
//        {
//            strokeVol = settingStrokeVol;
//            SVUpdatecounter=0;
//        }
    }

    if ( strokeVol >= HFO_STROKE_LIMIT)
        strokeVol = HFO_STROKE_LIMIT;

    Pres_Amp = MgrBreathData::S_GetInstance()->GetCurrentAmp()/10;

    // Calculate the phase angle.
    {
        Temp32 = 2*Freq;
        {
            int32_t	error;

            Dat_Omic = (Dat_Omic_integrator >> MAP_SERVO_SCALE);

            error = Temp32 - Dat_Omic;

            error <<= MAP_SERVO_SCALE;

            Dat_Omic_integrator += error/50; // 500 / 10;

        }
        Phase_Angle += Dat_Omic;


        if(Phase_Angle >= (int16_t)LENGTH_SINTBL)
            Phase_Angle -= (int16_t)LENGTH_SINTBL;
    }

    Phase = sin_table[Phase_Angle];

    // Read the final step from the table, remember stroke have been scaled by 10
    // to include the decimal portion for the setting less than 10.
    if ( strokeVol < 200)
    {
        if(isHummingVON == eTrue)
        {
            finalStep += steps_for_big_ml[strokeVol/10][Freq - MIN_FREQ] + strokeVol%10 + steps_offset_for_HummingV[strokeVol/10][Freq - MIN_FREQ];
        }
        else
        {
            finalStep += steps_for_big_ml[strokeVol/10][Freq - MIN_FREQ] + strokeVol%10;
        }
    }
    else
    {
        if(isHummingVON == eTrue)
        {
            finalStep += steps_for_big_ml[strokeVol/10][Freq - MIN_FREQ] + steps_offset_for_HummingV[strokeVol/10][Freq - MIN_FREQ];;
        }
        else
        {
            // 81 is he first large stroke volume.
            finalStep += steps_for_big_ml[strokeVol/10][Freq - MIN_FREQ];
        }
    }

    // Step amplitude calculate from the origin position.
    stepAmp = finalStep - (int32_t)H_Point;

    // Change of stroke volume will start the direct amplitude control
    // servo.
    LONG currentMapSetting = MgrBdSetting::S_GetInstance()
    ->GetCurrentValue(eHFOMap);


    if (( prevStrokeVol != settingStrokeVol)||(prevFreqSetting != Freq)
            ||(prevMapSetting != currentMapSetting))
    {
        prevMapSetting = currentMapSetting;
        prevStrokeVol = settingStrokeVol;
        prevFreqSetting = Freq;
        SetParameterForMotorAtOrgionalPos();
    }


    // Step amplitude calculate from the origin position.
    Temp32 = stepAmp;


    // Filter of stroke volume block, result is compute 2*Amp = DAmp
    {
        int32_t	error;

        DAmp = (DAmp_integrator >> MAP_SERVO_SCALE);

        error = Temp32 - DAmp;

        error <<= MAP_SERVO_SCALE;

        DAmp_integrator += error/100; // 500 / 10;

    }

    Temp32 = DAmp;


    /////////////////////////////////////////////////////
    {
        int16_t	output1;
        int32_t	error;

        output1 = (ZeroOrAmp_integrator1 >> MAP_SERVO_SCALE);

        error = Temp32 - output1;

        error <<= MAP_SERVO_SCALE;

        ZeroOrAmp_integrator1 += (error*6)/1000; // 500 / 10;

        ZeroOrAmp = (ZeroOrAmp_integrator2 >> MAP_SERVO_SCALE);

        error = output1 - ZeroOrAmp;

        error <<= MAP_SERVO_SCALE;

        ZeroOrAmp_integrator2 += (error/100); // 500 / 10;
    }



    // This is the case where stroke volume set to less than 10, but
    if ( (strokeVol < MIN_STROKE_FOR_OPEN_LOOP) || (strokeVol > MAX_STROKE_FOR_OPEN_LOOP) )
    {

        shifting_offset = openLoopShiftAmount;

        timeToGetTargetPress = 0;
        DAS_Counter = 0;

        Sum.Long32 = (int32_t)ZeroOrAmp*Phase;
        SinPos  =  Sum.access16.High16;
        SinPos += (ZeroOrAmp>>1);
    }
    else
    {
        //PresAmp_Cmd is pressure amplitude measured by previous open oscillation
        //Pres_Amp is real amplitude of pressure which is received from main CPU every 100 ms
        // Amp_ByDAC is Motor amplitude generated by direct amplitude control servo


        static bool printMsgOpenLoopFlag = true;
        static bool printMsgDCtrlFlag = false;
        int32_t	scaleUpInput,error;
        int32_t FAmp_ByDAC,Temp_Amp,Temp_int32;


        // Assume it is still making direct amplitude control.
        // The next couple of block will determine if it actually does.
        // If it is not the it will clear.
        Stop_DirectAmpCtrl = Make_DCShift;
        // 300 % rule, and 30 % rule. If this happens, then go to open loop.
        if ( FPres_Amp >= (3*PresAmp_Cmd) )
        {
            SetParameterForMotorAtOrgionalPos();
        }

        // If SI then go to open loop.
        if ( SIRequest )
        {
            Stop_DirectAmpCtrl = Sign_Res;
            if ( DAS_Counter < Five_Minutes)
            {
                SetParameterForMotorAtOrgionalPos();
            }
            else
            {
                DAS_Counter = Five_MPls10s;
            }
        }
        // 30 % rule could trigger because of SI
        if( FPres_Amp <= ((PresAmp_Cmd*3)/10)  )
        {

            if ( thirtyPercentDelay >= 500 )
            {
                Stop_DirectAmpCtrl = PresAmp50;
                // Notice use "less than", NOT "less than or equal"
                if ( timeToGetTargetPress < Thirty_Minutes )
                {
                    // Notice the shifting_offset did not reset to zero.
                    SetParameterForMotorAtOrgionalPos();
                }
                else
                {

                    if ( disconnectFlag == false)
                    {
                        disconnectFlag = true;
                        DAS_Counter = Five_MPls10s;
                    }

                }
            }
            else
            {
                thirtyPercentDelay++;
            }
        }
        else
        {
            thirtyPercentDelay = 0;

            if ( disconnectFlag == true )
            {
                DAS_Counter = Five_Minutes;
                disconnectFlag = false;
            }
        }



        if ( timeToGetTargetPress < Thirty_Minutes)
        {
            timeToGetTargetPress++;
        }



        FPresAmp_Cmd = (integrator_DAC1 >> MAP_SERVO_SCALE);

        if(DAS_Counter>=Five_Minutes)
            error = 0;
        else
            error = PresAmp_Cmd - FPresAmp_Cmd;

        error <<= MAP_SERVO_SCALE;

        integrator_DAC1 += error/500; // 500 / 1;

        if ( Stop_DirectAmpCtrl != Make_DCShift)
            Amp_ByDAC = prevAmp_ByDAC;
        else
            Amp_ByDAC = (integrator_DAC3 >> MAP_SERVO_SCALE);

        FAmp_ByDAC = (integrator_DAC2 >> MAP_SERVO_SCALE);

        error = Amp_ByDAC - FAmp_ByDAC;

        error <<= MAP_SERVO_SCALE;

        integrator_DAC2 += error/50; // 500 / 10;
        //..................................................................



        FPres_Amp = (integrator_DAC4 >> MAP_SERVO_SCALE);

        error = Pres_Amp- FPres_Amp;

        error <<= MAP_SERVO_SCALE;

        integrator_DAC4 += error/100; // 500 / 5;

        /* Fpres_Amp : Filtered Pres_Amp												*/
        if(Stop_DirectAmpCtrl == Make_DCShift)
            error = FPresAmp_Cmd - Pres_Amp;
        else
            error = 0;

        error = error<<1;

        scaleUpInput = (error << MAP_SERVO_SCALE);


        if((DAS_Counter < Five_MPls10s)&&(DAS_Counter>=Five_Minutes))
        {
            printMsgOpenLoopFlag = true;
            if ( printMsgDCtrlFlag )
            {
                printMsgDCtrlFlag = false;
            }
            // Direct amplitude control
            if(FAmp_ByDAC>=UpperAmpLimit)
            {
                if(scaleUpInput<0)
                    integrator_DAC3 += (scaleUpInput*3)/(2*5000);//
                Amp_ByDAC = UpperAmpLimit;
            }
            else if(FAmp_ByDAC<=LowerAmpLimit)
            {
                if(scaleUpInput>0)
                    integrator_DAC3 += (scaleUpInput*3)/(2*5000);
                Amp_ByDAC = LowerAmpLimit;
            }
            else
                integrator_DAC3 += (scaleUpInput*3)/(2*5000);

            Sum.Long32 = (int32_t)Amp_ByDAC*Phase;
            SinPos  =  Sum.access16.High16;
            SinPos += (Amp_ByDAC>>1);

        }
        else
        {
            // Open loop turn
            printMsgDCtrlFlag = true;
            if ( printMsgOpenLoopFlag )
            {
                printMsgOpenLoopFlag = false;
            }

            // Do the target making
            if(DAS_Counter<Five_Minutes)
            {
                Temp_Amp = ZeroOrAmp;
                PresAmp_Cmd = Pres_Amp;
                integrator_DAC3 = (Temp_Amp << MAP_SERVO_SCALE);
            }
            else
            {
                Temp_Amp = Amp_ByDAC;
            }

            // Setup limit for next FBC. 90, 110 % rule.
            UpperAmpLimit = (11*Temp_Amp)/10;
            LowerAmpLimit = (9*Temp_Amp)/10;



            /*200 % rule. Limit from exceed it 200 % of step amplitude from origin position.
                                    ZeroOrAmp is initial step amplitude */
            Temp_int32 = (stepAmp*20)/10;
            if( UpperAmpLimit > Temp_int32)
                UpperAmpLimit = Temp_int32;

            // 80 % rule. Khoi add this per Mr Kayahara request.
            Temp_int32 = (stepAmp*8)/10;
            if( LowerAmpLimit < Temp_int32)
                LowerAmpLimit = Temp_int32;

            OpenMtr_Amp = Temp_Amp;

            Sum.Long32 = (int32_t)Temp_Amp*Phase;
            SinPos  =  Sum.access16.High16;
            SinPos += (Temp_Amp>>1);
        }

        /* ABove two sentences could be deleted if DC should be used
         * for SV from 0 ~ 80												  */

        if(Stop_DirectAmpCtrl == Make_DCShift)
            DAS_Counter++;

        // Reset counter to 5:00, and do the shifting.
        if(DAS_Counter>Ten_Minutes)
        {
            DAS_Counter=Five_Minutes;

            prevAmp_ByDAC = Amp_ByDAC;

            shifting_offset += shifting_inc;

            if((shifting_offset+H_Point+OpenMtr_Amp)>=1800)
            {
                shifting_inc = -SHIFT_INCREMENT;
            }
            if(shifting_offset<0)
            {
                shifting_inc = SHIFT_INCREMENT;
                shifting_offset = 0;
            }
        }
    }



    {
        Temp32 = (int32_t)H_Point;
        // if making center shifting, add the following lines to Temp32 += shfiting_offset.
        Temp32 += shifting_offset;
    }
    /////////////////////////////////////////////////////////
    {
        int16_t	output1;
        int32_t	error;

        output1 = (EHPoint_integrator1 >> MAP_SERVO_SCALE);

        error = Temp32 - output1;

        error <<= MAP_SERVO_SCALE;

        EHPoint_integrator1 += (error)/50;			//15)/500;

        EHPoint = (EHPoint_integrator2 >> MAP_SERVO_SCALE);

        error = output1 - EHPoint;

        error <<= MAP_SERVO_SCALE;

        EHPoint_integrator2 += (error/500);			//12/500);
    }
    HFO_Mposition = EHPoint;
    HFO_Mposition += (int32_t)SinPos;


    if( HFO_Mposition < 0 )
        HFO_Mposition = 0;

    if(HFO_Mposition < prevStep)
    {
        prevStep = HFO_Mposition;
    }

    static bool isSendToMapCtn = false;
    if(IsSIReqPrev)
    {

        MgrStemMotor::HfoValve->RampToPosition(H_Point);
        numOfSample++;
        sum +=HFO_Mposition;
        {

            if(MgrStemMotor::HfoValve->GetStepPosition()<= H_Point)
            {
                if(!isSendToMapCtn)
                {
//                    HfoController->SetSIRequest(SIRequest);

                    isSendToMapCtn = true;


                }
                SetStatic();
            }
            numOfSample = 0;
            sum = 0;
        }
    }
    else
    {
        numOfSample = 0;
        sum = 0;
        MgrStemMotor::HfoValve->SetStepPosition(HFO_Mposition);
        prevStep = HFO_MAX_STEP;
        isSendToMapCtn = false;
    }
}


//*****************************************************************//
// Gets freq, stroke volume and SI request from BD CPU
//*****************************************************************//
void HfoServo::GetCurrentSettings()
{
}
void HfoServo::SetStatic()
{
    DAmp_integrator = 255;
    ZeroOrAmp_integrator1 = 255;
    ZeroOrAmp_integrator2 = 254;
    EHPoint_integrator1 = 99588;
    EHPoint_integrator2 = 99328;
    DAS_Counter = 0;
    timeToGetTargetPress = 0;
    UpperAmpLimit = 18;
    LowerAmpLimit = 15 ;
    PresAmp_Cmd = 1;
    Pres_Amp = 1;
    FPres_Amp = 2;
    Amp_ByDAC = 9;
    prevAmp_ByDAC = 0 ;
    OpenMtr_Amp = 18 ;
    integrator_DAC1 = 22509 ;
    integrator_DAC2 = 4950 ;
    integrator_DAC3 = 4608 ;
    integrator_DAC4 = 16104 ;

}

//*****************************************************************//
// Calculate the phase angle.
//*****************************************************************//
void HfoServo::CalculatePhaseAngle()
{

}

//*****************************************************************//
// Calculate the amplitude
//*****************************************************************//
void HfoServo::AmplitudeFilter()
{

}

//*****************************************************************************//
//
//--------------Direct Amplitude Control, run every 2ms -----------------------//
//
// PresAmp_Cmd is pressure amplitude measured by previous open oscillation
// Pres_Amp is real amplitude of pressure which is received from main CPU every 100 ms
// Amp_ByDAC is Motor amplitude generated by direct amplitude control servo
//
//*****************************************************************************//
void HfoServo::DirectAmplitudeControl()
{
}
// Amp_ByDAC should be remembed after 10s Direct Amplitude control
//-------- End of Direct amplitude control -------------------------//


//***************************************************************************//
//
//***************************************************************************//
void HfoServo::UpdateControlStatus()
{
}

//***************************************************************************//
//
//***************************************************************************//
void HfoServo::HfoPositionFilter()
{

}
//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: ClearStaticVariables()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::ClearStaticVariables()
{
    //    CM
    Dat_Omic_integrator = 0;
    DAmp_integrator = 0;
    ZeroOrAmp_integrator1 = 0;
    ZeroOrAmp_integrator2 = 0;
    EHPoint_integrator1 = 0;
    EHPoint_integrator2 = 0;
    zeroIntegrator1 = 0;
    zeroIntegrator2 = 0;
    freqIntegrator = 0;
    dAmpIntegrator = 0;
    strokeVol = 0;
    SVUpdatecounter = 0;

    shifting_offset = 0;
    DAS_Counter		= 0;

    timeToGetTargetPress = 0;
    PresAmp_Cmd = 0;
    Pres_Amp = 0;
    FPres_Amp = 0;
    Amp_ByDAC = 0;
    prevAmp_ByDAC = 0;
    OpenMtr_Amp = 0;
    integrator_DAC1 = 0;
    integrator_DAC2 = 0;
    integrator_DAC3 = 0;
    integrator_DAC4 = 0;
    UpperAmpLimit = 0;
    LowerAmpLimit = 0;

    PresAmp_Cmd = 0;
    Pres_Amp = 0;
    FPres_Amp = 0;
    Amp_ByDAC = 0;
    prevAmp_ByDAC = 0;

    OpenMtr_Amp = 0;
    integrator_DAC1 = 0;
    integrator_DAC2 = 0;
    integrator_DAC3 = 0;
    integrator_DAC4 = 0;
    UpperAmpLimit = 0;
    LowerAmpLimit = 0;

    prevSI = eFalse;
    delay_afterSI = 0;
}
//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: Enable()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::Enable(void)
{
//    Enabled = eTrue;
}
//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: SetSIRequest(E_Bool SIrequest)
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::SetSIRequest(E_Bool SIrequest)
{
    SIRequest = SIrequest;
}
/******************************************************************************/
//$COMMON.OPERATION$
//    Operation Name: Reset_20sTimer()
//
//    Processing:
//      Reset Timer 20s
//
//    Input Parameters:
//      None
//
//    Output Parameters:
//      None
//
//    Return Values:
//      None
//
//    Pre-Conditions:
//      None
//
//    Miscellaneous:
//      None
//
//    Requirements:
//
/******************************************************************************/
void HfoServo::Reset_20sTimer()
{
    Timer_20s = 0;
    finished_20s = false;
}
/******************************************************************************/
//$COMMON.OPERATION$
//    Operation Name: ResetPIDStatic()
//
//    Processing:
//      Reset PID
//
//    Input Parameters:
//      None
//
//    Output Parameters:
//      None
//
//    Return Values:
//      None
//
//    Pre-Conditions:
//      None
//
//    Miscellaneous:
//      None
//
//    Requirements:
//
/******************************************************************************/
void HfoServo::ResetPIDStatic()
{
    Amp_integral = 0;
    Amp_derivative = 0;
    currentAmp=0;
}
//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: RequestDoAmpCtr()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::RequestDoAmpCtr()
{
    currentAmp = MgrBreathData::S_GetInstance()->GetCurrentAmp()/SCALE;

    LONG settingAmp = MgrBdSetting::S_GetInstance()->GetCurrentValue(eAmplitude)/SCALE;

    LONG errorAmp = settingAmp - currentAmp;

    Amp_derivative = errorAmp;
    Amp_integral = (strokeVol - (Kp+Kd)*errorAmp)/Ki;

    IsDoAmpCtr = true;
    if(SIRequest)
        ResetPIDStatic();
}

void HfoServo //: public Controller
::Disable (void)
{
}

//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: DoPID()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
int16_t HfoServo::DoPID()
{
    int16_t strokeVol;

    currentAmp = MgrBreathData::S_GetInstance()->GetCurrentAmp()/SCALE;

    LONG settingAmp = MgrBdSetting::S_GetInstance()->GetCurrentValue(eAmplitude)/SCALE;

    if(settingAmp == 0)
        return 0;

    LONG errorAmp = settingAmp - currentAmp;




    Amp_integral = Amp_integral + errorAmp*2; // integral = integral + errorAmp*dt

    Amp_derivative = (errorAmp - prev_Amp_error)/2;


    strokeVol = Kp*errorAmp + Ki*Amp_integral + Kd*Amp_derivative;

    prev_Amp_error = errorAmp;


    LONG FreqSetting = MgrBdSetting::S_GetInstance()->GetCurrentValue(eHFOFrequency)/SCALE;

    int index = FreqSetting - 5;
    LONG Max_SV = MAX_STROKE_VOLUME[index];


    if(strokeVol > Max_SV*10)
    {        
        strokeVol = Max_SV*10;
    }
    if(strokeVol<0)
        strokeVol = 0;
    return strokeVol;
}
//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: StopDoAmpCtr()
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::StopDoAmpCtr()
{
    IsDoAmpCtr = false;
}

//******************************************************************************
//$COMMON.OPERATION$
//    Operation Name: SetHummingVON(E_Bool value)
//
//    Processing:
//
//    Input Parameters:
//
//    Output Parameters:  None
//    Return Values:
//    Pre-Conditions:
//    Miscellaneous: None
//    Requirements:
//
//******************************************************************************
void HfoServo::SetHummingVON(E_Bool value)
{
    isHummingVON = value;
//    MainHandlerDelegate::S_GetInstance()->postCustomEvent<E_Bool>(eHummingVEvent, value);
//
//    FileTaskEvent fEvent;
//    fEvent.infoID = SETTING_IDX(eHummingVSettingID);
//    fEvent.info = QString::number((LONG)value);
//    LogFileHandler::S_GetInstance()->postCustomEvent<FileTaskEvent>(LogFileHandler::eLogHandlerVentSettingFileType, fEvent);

}
